/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2312                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

convertToMetres 1;

// Geometric parameters
D_i 0.6e-3;
D_o 1.0e-3;
D_a 5e-3;
L_b 7.0e-3;
L_a 70e-3;
thetaDgr 0.5;

// Cell count
cellsAxialAir 100;
cellsRadialAir 50;

expRatioAxial 20;
expRatioRadial 5;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
// The rest of the code automatically creates the mesh, using the above parameters.
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Calculate parameters
thetaRad #calc "degToRad($thetaDgr)";
reverseExpRatioAxial #calc "1.0/$expRatioAxial";
R_i #calc "$D_i /2.0";
R_o #calc "$D_o /2.0";
R_a #calc "$D_a /2.0";

// Calculate uniform cells
Dxn (#codeStream {
    code #{
        scalar suma = 0;
        int i = 0;
        for (i=0 ; i<$cellsAxialAir ; i++)
            suma += pow($expRatioAxial , (i/($cellsAxialAir - 1.0)) );
        os << ($L_a)/suma << endl;
    #};
} ); 

Dyn (#codeStream {
    code #{
        scalar suma = 0;
        int i = 0;
        for (i=0 ; i<$cellsRadialAir ; i++)
            suma += pow($expRatioRadial , (i/($cellsRadialAir - 1.0)) );
        os << ($R_a-$R_o)/suma << endl;
    #};
} ); 
cellsRadialDiel #calc "int(1.0*($R_o-$R_i)/$Dyn + 0.5)";
cellsRadialGas #calc "int(1.0*($R_i)/$Dyn + 0.5)";

// Calculate vertices' coordinates
X0 #calc "0";                                     Y0 #calc "0";
X1 #calc "-$R_i*sin(0.5*$thetaRad)";              Y1 #calc "$R_i*cos(0.5*$thetaRad)";
X2 #calc "$R_i*sin(0.5*$thetaRad)";               Y2 #calc "$R_i*cos(0.5*$thetaRad)";
X3 #calc "-$R_o*sin(0.5*$thetaRad)";              Y3 #calc "$R_o*cos(0.5*$thetaRad)";
X4 #calc "$R_o*sin(0.5*$thetaRad)";               Y4 #calc "$R_o*cos(0.5*$thetaRad)";
X5 #calc "-$R_a*sin(0.5*$thetaRad)";              Y5 #calc "$R_a*cos(0.5*$thetaRad)";
X6 #calc "$R_a*sin(0.5*$thetaRad)";               Y6 #calc "$R_a*cos(0.5*$thetaRad)";

vertices
(
    ($X0 $Y0 $L_b)            // 0
    ($X1 $Y1 $L_b)            // 1
    ($X2 $Y2 $L_b)            // 2
    ($X3 $Y3 $L_b)            // 3
    ($X4 $Y4 $L_b)            // 4
    ($X5 $Y5 $L_b)            // 5
    ($X6 $Y6 $L_b)            // 6

    ($X0 $Y0 $L_a)            // 7
    ($X1 $Y1 $L_a)            // 8
    ($X2 $Y2 $L_a)            // 9
    ($X3 $Y3 $L_a)            // 10
    ($X4 $Y4 $L_a)            // 11
    ($X5 $Y5 $L_a)            // 12
    ($X6 $Y6 $L_a)            // 13
);

blocks
(
    hex (0 7 7 0 1 8 9 2) ($cellsAxialAir 1 $cellsRadialGas) simpleGrading ($expRatioAxial 1 1) // Block 0
    hex (1 8 9 2 3 10 11 4) ($cellsAxialAir 1 $cellsRadialDiel) simpleGrading ($expRatioAxial 1 1) // Block 1
    hex (3 10 11 4 5 12 13 6) ($cellsAxialAir 1 $cellsRadialAir) simpleGrading ($expRatioAxial 1 1) // Block 2
);

boundary
(
    gasInlet
    {
        type patch;
        faces
        (
            (0 1 2 0)   // From Block 0
        );
    }

    region0_to_dielectric
    {
        type wall;
        faces
        (
            (1 3 4 2)   // From Block 1
        );
    }

    airInlet
    {
        type patch;
        faces
        (
            (3 5 6 4)   // From Block 2
        );
    }

    outlet
    {
        type patch;
        faces
        (
            (7 9 8 7)   // From Block 0
            (8 9 11 10)   // From Block 1
            (10 11 13 12)   // From Block 2
        );
    }

    topBoundary
    {
        type patch;
        faces
        (
            (5 12 13 6)   // From Block 2
        );
    }

    axis
    {
        type empty;
        faces
        (
            (0 7 7 0)   // From Block 0
        );
    }

    frontWedge
    {
        type wedge;
        faces
        (
            (0 7 8 1)   // From Block 0
            (1 8 10 3)   // From Block 1
            (3 10 12 5)   // From Block 2
        );
    }

    backWedge
    {
        type wedge;
        faces
        (
            (0 2 9 7)   // From Block 0
            (2 4 11 9)   // From Block 1
            (11 4 6 13)   // From Block 2
        );
    }

);
